# Halftone Lines


## Algorithm

### 1. The Kernel and the Quadrants

The algorithm scans the input image in its four quadrants. This is done by finding the center of the image (variables `x_center` and `y_center`) and placing four squared kernels there, like so:
```
   +-------+      +-------+      +-------+
   |       |      |       |      | +-+-+ |    
   |       |      |   o   |      | +-o-+ |        
   |       |      |       |      | +-+-+ |        
   +-------+      +-------+      +-------+
   input img      input img   the four squares   
                    center    around the center
```
These kernels are defined by the array `vertices` in the `quadrant` method of the [`Scan` class](https://github.com/GravO8/halftone-lines/blob/master/scan.py). They are constructed from the base kernel defined by the vertices `(0,0)`, `(0,kernel_s)`, `(kernel_s,kernel_s)` and `(kernel_s,0)`, where `kernel_s` stands for *"kernel side"*. 

The arguments `h_sign` and `v_sign` (horizontal and vertical sign, respectively) are used to diferentiate four kernels (and quadrants):
```
(h_sign = +1) and (v_sign = +1) is the first quadrant (top right)
(h_sign = -1) and (v_sign = +1) is the second quadrant (top left)
(h_sign = -1) and (v_sign = -1) is the third quadrant (bottom left)
(h_sign = +1) and (v_sign = -1) is the fourth quadrant (bottom right)
```
[This image](https://p.tutorme.click/media/8c8c4f25a61c0551b6825e7ba45f573a.png) may help visualize the quadrants and their respective horizontal and vertical signs.

The vertices are then rotated by `angle` degrees using the rotation matrix generated by the `rotation_matrix` function:
```python
r_matrix   = rotation_matrix(angle)
vertices_r = r_matrix.dot(vertices).T
```
and moved to the center of the image by adding the center coordinates:
```python
vertices_r = vertices_r + np.array([x_center, y_center])
```

### 2. Sliding Window

Ok, the kernels are in place. How can they be moved to scan the image? This is done with the `move_h_r` and `move_v_r` variables, that move the kernels horizontally and vertically, respectively. And are defined like so:

```
move_h_r = r_matrix.dot( np.array([kernel_s,0]) )
move_v_r = r_matrix.dot( np.array([0,kernel_s]) )
```

They too are rotated by `angle` degrees to match the orientation of the kernels. 





The algorithm can be optimized by directly updating the `StraightLine` objects instead of constructing new objects everytime the kernel is moved.

